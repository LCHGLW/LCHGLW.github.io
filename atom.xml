<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.imlch.cn/"/>
  <updated>2020-12-07T14:35:10.780Z</updated>
  <id>http://blog.imlch.cn/</id>
  
  <author>
    <name>imlch</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/12/07/Catboost/"/>
    <id>http://blog.imlch.cn/2020/12/07/Catboost/</id>
    <published>2020-12-07T13:08:38.493Z</published>
    <updated>2020-12-07T14:35:10.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>天池学习赛贷款违约预测</p><p>首次参加学习赛的过程在论坛中初识catBoost，希望能通过实践加深印象与理解</p><h3 id="catboost-简介"><a href="#catboost-简介" class="headerlink" title="catboost 简介"></a>catboost 简介</h3><p>###三大优点</p><ul><li>自动处理<strong>类别型特征（categorical features）</strong>。首先对categorical features做一些统计，计算某个类别特征（category）出现的频率，之后加上超参数，生成新的数值型特征（numerical features）</li><li>catboost还使用了<strong>组合类别特征</strong>，可以利用到特征之间的联系，这极大的<strong>丰富了特征维度</strong>。</li><li>catboost的基模型采用的是<strong>对称树</strong>，同时计算leaf-value方式和传统的boosting算法也不一样，传统的boosting算法计算的是平均数，而catboost在这方面做了优化采用了其他的算法，这些改进都能<strong>防止模型过拟合</strong>。</li></ul><h3 id="catboost-实战"><a href="#catboost-实战" class="headerlink" title="catboost 实战"></a>catboost 实战</h3><p>首先通过pandas读入数据。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line">from sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line">#warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br><span class="line">#%matplotlib <span class="keyword">inline</span></span><br><span class="line">from sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line">## 数据降维处理的</span><br><span class="line">from sklearn.model_selection <span class="keyword">import</span> train_test_split  </span><br><span class="line">from catboost <span class="keyword">import</span> CatBoostClassifier</span><br><span class="line">train=pd.read_csv(<span class="string">"train.csv"</span>)</span><br><span class="line">testA=pd.read_csv(<span class="string">"testA.csv"</span>)</span><br></pre></td></tr></table></figure><p>数据中包含了47种不同特征，而且特征的数据类型各不一样，有数值型（creative_height），布尔型（creative_is_js)等不同类型的特征。</p><p><img src="https:////upload-images.jianshu.io/upload_images/9168245-bb0e903791cb5919.png?imageMogr2/auto-orient/strip|imageView2/2/w/1104/format/webp" alt="img"></p><p>而在catboost中不需要预处理数据，只需要提供，哪些特征属于类别特征，它会自动处理。代码如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sub=testA[[<span class="string">'id'</span>]].copy()</span><br><span class="line">sub[<span class="string">'isDefault'</span>]=<span class="number">0</span></span><br><span class="line">testA=testA.drop([<span class="string">'id'</span>,<span class="string">'issueDate'</span>],axis=<span class="number">1</span>)</span><br><span class="line">data_x=train.drop([<span class="string">'isDefault'</span>,<span class="string">'id'</span>,<span class="string">'issueDate'</span>],axis=<span class="number">1</span>)</span><br><span class="line">data_y=train[[<span class="string">'isDefault'</span>]].copy()</span><br><span class="line">x, val_x, y, val_y = train_test_split(  </span><br><span class="line">    data_x,  </span><br><span class="line">    data_y,  </span><br><span class="line">    test_size=<span class="number">0.25</span>,  </span><br><span class="line">    random_state=<span class="number">1</span>,  </span><br><span class="line">    stratify=data_y</span><br><span class="line">)  </span><br><span class="line"></span><br><span class="line">col=[<span class="string">'grade'</span>,<span class="string">'subGrade'</span>,<span class="string">'employmentTitle'</span>,<span class="string">'homeOwnership'</span>,<span class="string">'verificationStatus'</span>,<span class="string">'purpose'</span>,<span class="string">'postCode'</span>,<span class="string">'regionCode'</span>,</span><br><span class="line">     <span class="string">'initialListStatus'</span>,<span class="string">'applicationType'</span>,<span class="string">'policyCode'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data_x.columns:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> col:</span><br><span class="line">        data_x[i] = data_x[i].astype(<span class="string">'str'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> testA.columns:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> col:</span><br><span class="line">        testA[i] = testA[i].astype(<span class="string">'str'</span>)</span><br><span class="line">model=CatBoostClassifier(</span><br><span class="line">            loss_function=<span class="string">"Logloss"</span>,</span><br><span class="line">            eval_metric=<span class="string">"AUC"</span>,</span><br><span class="line">            task_type=<span class="string">"CPU"</span>,</span><br><span class="line">            learning_rate=<span class="number">0.1</span>,</span><br><span class="line">            iterations=<span class="number">500</span>,</span><br><span class="line">            random_seed=<span class="number">2020</span>,</span><br><span class="line">            od_type=<span class="string">"Iter"</span>,</span><br><span class="line">            depth=<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>最后就是将数据喂给算法进行训练</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">answers = []</span><br><span class="line">mean_score = <span class="number">0</span></span><br><span class="line">n_folds = <span class="number">5</span></span><br><span class="line">sk = StratifiedKFold(n_splits=n_folds, shuffle=<span class="keyword">True</span>, random_state=<span class="number">2019</span>)</span><br><span class="line"><span class="keyword">for</span> train, test in sk.split(data_x, data_y):</span><br><span class="line">    x_train = data_x.iloc[train]</span><br><span class="line">    y_train = data_y.iloc[train]</span><br><span class="line">    x_test = data_x.iloc[test]</span><br><span class="line">    y_test = data_y.iloc[test]</span><br><span class="line">    clf = model.fit(x_train,y_train, eval_set=(x_test,y_test),verbose=<span class="number">500</span>,cat_features=col)</span><br><span class="line">    yy_pred_valid=clf.predict(x_test)</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">'cat验证的auc:&#123;&#125;'</span>.format(roc_auc_score(y_test, yy_pred_valid)))</span><br><span class="line">    mean_score += roc_auc_score(y_test, yy_pred_valid) / n_folds</span><br><span class="line">    y_pred_valid = clf.predict(testA,prediction_type=<span class="string">'Probability'</span>)[:,<span class="number">-1</span>]</span><br><span class="line">    answers.append(y_pred_valid)</span><br><span class="line"><span class="keyword">print</span>(<span class="string">'mean valAuc:&#123;&#125;'</span>.format(mean_score))</span><br><span class="line">cat_pre=sum(answers)/n_folds</span><br><span class="line">sub[<span class="string">'isDefault'</span>]=cat_pre</span><br><span class="line">sub.to_csv(<span class="string">'D:/projects/python/test/jupyter/金融预测.csv'</span>,index=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>catboot简单易用且功能强大，减弱了对特征工程的依赖，如果面对需要特别多的<strong>前期数据处理和特征数值化</strong>的任务，可以很高效锋发挥作用。</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;天池学习赛贷款违约预测&lt;/p&gt;
&lt;p&gt;首次参加学习赛的过程在论坛中初识catBoost，希望能通过实践加深印象与理解&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/11/22/%E8%87%AA%E5%AE%9A%E4%B9%89jupyter%E4%B8%BB%E9%A2%98/"/>
    <id>http://blog.imlch.cn/2020/11/22/自定义jupyter主题/</id>
    <published>2020-11-22T14:46:03.841Z</published>
    <updated>2020-11-22T15:05:07.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>原生的白色主题不适合在晚上长时间使用，尝试更换整个主题或者自定义透明背景等细节</p><p>原生的字体也比较小，尝试修改字体类型及大小</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>通过修改本地路径的css文件，修改网页样式的原理来完成主题修改</li><li>不熟悉原生CSS文件架构，可选择使用jupyter thems 这个包来直接安装主题</li></ul><p>*<em>可选择主题</em>plotting style*</p><h6 id="markdown-equations"><a href="#markdown-equations" class="headerlink" title="markdown/equations"></a><em>markdown/equations</em></h6><p><a href="https://github.com/dunovank/jupyter-themes/blob/master/screens/oceans16_markdown.png" target="_blank" rel="noopener"><img src="https://github.com/dunovank/jupyter-themes/raw/master/screens/oceans16_markdown.png" alt="image"></a></p><h6 id="pandas-dataframes"><a href="#pandas-dataframes" class="headerlink" title="pandas dataframes"></a><em>pandas dataframes</em></h6><p><a href="https://github.com/dunovank/jupyter-themes/blob/master/screens/grade3_table.png" target="_blank" rel="noopener"><img src="https://github.com/dunovank/jupyter-themes/raw/master/screens/grade3_table.png" alt="image"></a></p><h6 id="command-palette"><a href="#command-palette" class="headerlink" title="command palette"></a><em>command palette</em></h6><p><img src="https://github.com/dunovank/jupyter-themes/raw/master/screens/oceans16_command_palette.png" alt="image"></p><h6 id="grade3-syntax"><a href="#grade3-syntax" class="headerlink" title="grade3 syntax"></a><em>grade3 syntax</em></h6><p><a href="https://github.com/dunovank/jupyter-themes/blob/master/screens/grade3_code_headers.png" target="_blank" rel="noopener"><img src="https://github.com/dunovank/jupyter-themes/raw/master/screens/grade3_code_headers.png" alt="image"></a></p><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> jupyterthemes</span><br></pre></td></tr></table></figure><ul><li><p>参数说明</p><p>-t 设置主题， -f 设置代码的字体， -nf 设置notebook的字体，具体参数说明<br><img src="https://img-blog.csdnimg.cn/20190320155914209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzUwOTI2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>更换主题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -t chesterish</span><br></pre></td></tr></table></figure></li><li><p>恢复默认主题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -r</span><br></pre></td></tr></table></figure></li><li><p>查看可用主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -l</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;原生的白色主题不适合在晚上长时间使用，尝试更换整个主题或者自定义透明背景等细节&lt;/p&gt;
&lt;p&gt;原生的字体也比较小，尝试修改字
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/11/15/Hexo%E8%BD%AC%E4%B9%89%E5%A4%B1%E8%B4%A5/"/>
    <id>http://blog.imlch.cn/2020/11/15/Hexo转义失败/</id>
    <published>2020-11-15T13:55:33.251Z</published>
    <updated>2020-11-15T13:56:22.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在 Hexo 搭建的博客中对文章进行编写，经常会用到一些特殊字符需要转译，比如 <code>-</code>、<code>.</code>、空格、制表符等等，在正常情况下可以使用 <code>\</code> 进行转译，但是有一些字符无法转译，使用后在执行 <code>hexo server</code> 命令的时候会报错。</p><p><strong>报错信息：</strong></p><blockquote><p>Unhandled rejection Template render error: (unknown path) [Line 7, Column 23]<br>Error: Unable to call <code>worldcount</code>, which is undefined or falsey……</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>报错的原因是，Hexo 编译时发生错误，可能是文章中存在特殊字符，如：{ [ ( ) ] } 等等。如下面这段代码：</p><p><strong>在页面中：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; worldcount(post.content) &#125;&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>在 Markdown 中：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;#123;&amp;#123; worldcount&amp;#40;post.content&amp;#41; &amp;#125;&amp;#125;</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>在 Markdown 中使用 <code>\</code> 无法转译的字符需要使用字符的命名实体或十进制编码，如上面代码中。</p><p><strong><em>注意：需要转义的字符只是文本中的特殊字符，代码块中的特殊字符无需转译或使用转译字符。</em></strong></p><h2 id="常见特殊字符"><a href="#常见特殊字符" class="headerlink" title="常见特殊字符"></a>常见特殊字符</h2><p>常用特殊字符转译字符对照表：</p><table><thead><tr><th>特殊符号</th><th>命名实体</th><th>十进制编码</th></tr></thead><tbody><tr><td>空格</td><td>&nbsp;</td><td>&#160;</td></tr><tr><td>全角空格</td><td>&emsp;</td><td>&#12288;</td></tr><tr><td>’</td><td>&apos;</td><td>&#39;</td></tr><tr><td>“</td><td>&quot;</td><td>&#34;</td></tr><tr><td>(</td><td>—</td><td>&#40;</td></tr><tr><td>)</td><td>—</td><td>&#41;</td></tr><tr><td>&lt;</td><td>&lt;</td><td>&#60;</td></tr><tr><td>&gt;</td><td>&gt;</td><td>&#62;</td></tr><tr><td>[</td><td>—</td><td>&#91;</td></tr><tr><td>]</td><td>—</td><td>&#93;</td></tr><tr><td>{</td><td>—</td><td>&#123;</td></tr><tr><td>}</td><td>—</td><td>&#125;</td></tr><tr><td>´</td><td>&acute;</td><td>&#180;</td></tr><tr><td>°</td><td>&deg;</td><td>&#176;</td></tr><tr><td>®</td><td>&reg;</td><td>&#174;</td></tr><tr><td>©</td><td>&copy;</td><td>&#169;</td></tr></tbody></table><p>常用数学转译字符对照表：</p><table><thead><tr><th>特殊符号</th><th>命名实体</th><th>十进制编码</th></tr></thead><tbody><tr><td>≤</td><td>&le;</td><td>&#8804;</td></tr><tr><td>≥</td><td>&ge;</td><td>&#8805;</td></tr><tr><td>≈</td><td>&asymp;</td><td>&#8773;</td></tr><tr><td>≠</td><td>&ne;</td><td>&#8800;</td></tr><tr><td>∩</td><td>&cap;</td><td>&#8745;</td></tr><tr><td>∪</td><td>&cup;</td><td>&#8746;</td></tr><tr><td>∠</td><td>&ang;</td><td>&#8736;</td></tr><tr><td>∞</td><td>&infin;</td><td>&#8734;</td></tr><tr><td>±</td><td>&plusmn;</td><td>&#177;</td></tr><tr><td>√</td><td>&radic;</td><td>&#8730;</td></tr><tr><td>∑</td><td>&sum;</td><td>&#8722;</td></tr><tr><td>∫</td><td>&int;</td><td>&#8747;</td></tr><tr><td>Δ</td><td>&Delta;</td><td>&#916;</td></tr></tbody></table><p>常用希腊字母转译字符对照表：</p><table><thead><tr><th>特殊符号</th><th>命名实体</th><th>十进制编码</th></tr></thead><tbody><tr><td>Φ</td><td>&Phi;</td><td>&#934;</td></tr><tr><td>Ω</td><td>&Omega;</td><td>&#937;</td></tr><tr><td>α</td><td>&alpha;</td><td>&#945;</td></tr><tr><td>β</td><td>&beta;</td><td>&#946;</td></tr><tr><td>γ</td><td>&gamma;</td><td>&#947;</td></tr><tr><td>δ</td><td>&delta;</td><td>&#948;</td></tr><tr><td>ε</td><td>&epsilon;</td><td>&#949;</td></tr><tr><td>ζ</td><td>&zeta;</td><td>&#950;</td></tr><tr><td>η</td><td>&eta;</td><td>&#951;</td></tr><tr><td>θ</td><td>&theta;</td><td>&#952;</td></tr><tr><td>λ</td><td>&lambda;</td><td>&#955;</td></tr><tr><td>μ</td><td>&mu;</td><td>&#956;</td></tr><tr><td>ξ</td><td>&xi;</td><td>&#958;</td></tr><tr><td>π</td><td>&pi;</td><td>&#960;</td></tr><tr><td>ρ</td><td>&rho;</td><td>&#961;</td></tr><tr><td>σ</td><td>&sigma;</td><td>&#963;</td></tr><tr><td>φ</td><td>&phi;</td><td>&#966;</td></tr><tr><td>ψ</td><td>&psi;</td><td>&#968;</td></tr><tr><td>ω</td><td>&omega;</td><td>&#969;</td></tr><tr><td>∂</td><td>&part;</td><td>&#8706;</td></tr><tr><td>∅</td><td>&empty;</td><td>&#8709;</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在 Hexo 搭建的博客中对文章进行编写，经常会用到一些特殊字符需要转译，比如 &lt;code&gt;-&lt;/code&gt;、&lt;code&gt;.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/11/07/Trie%E6%A0%91/"/>
    <id>http://blog.imlch.cn/2020/11/07/Trie树/</id>
    <published>2020-11-07T10:28:05.752Z</published>
    <updated>2020-11-08T07:04:53.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><h4 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212. 单词搜索 II"></a><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">212. 单词搜索 II</a></h4><p>难度困难278</p><p>给定一个二维网格 <strong>board</strong> 和一个字典中的单词列表 <strong>words</strong>，找出所有同时在二维网格和字典中出现的单词。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =</span><br><span class="line">[</span><br><span class="line">  [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],</span><br><span class="line">  [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],</span><br><span class="line">  [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],</span><br><span class="line">  [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出: [&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>你可以假设所有输入都由小写字母 <code>a-z</code> 组成。</p><p><strong>提示:</strong></p><p>Trie树应用广泛， NLP 中一般会用其存储大量的字典字符以用于文本的快速分词；除此之外，典型应用场景还包括大批量文本的：词频统计、字符串查询和模糊匹配（比如关键词的模糊匹配）、字符串排序等任务；（还比如搜索引擎）。由于 Trie 大幅降低了无谓的字符串比较，因此在执行上述任务时，其效率非常的高。</p><h2 id="二、Trie-树的简介"><a href="#二、Trie-树的简介" class="headerlink" title="二、Trie 树的简介"></a>二、Trie 树的简介</h2><p>Trie 树中文名叫字典树、前缀树等等。这些名字暗示其与字符的处理有关，事实也确实如此，它主要用途就是将字符串（当然也可以不限于字符串）整合成树形。</p><p><img src="https://image-static.segmentfault.com/881/635/881635732-58d38beb5f735_articlex" alt="img"></p><p>这个树里面每一个方块代表一个节点，其中 ”Root” 表示根节点，不代表任何字符；紫色代表分支节点；绿色代表叶子节点。除根节点外<strong>每一个节点都只包含一个字符</strong>。从根节点到叶子节点，路径上经过的字符连接起来，构成一个词。而叶子节点内的数字代表该词在字典树中所处的链路（字典中有多少个词就有多少条链路），具有共同前缀的链路称为串。除此之外，    还需特别强调 Trie 树的以下几个特点：</p><ol><li><p>具有相同前缀的词必须位于同一个串内；例如“清华”、“清新”两个词都有“清”这个前缀，那么在 Trie 树上只需构建一个“清”节点，“华”和“新”节点共用一个父节点即可，如此两个词便只需三个节点便可存储，这在一定程度上减少了字典的存储空间。</p></li><li><p>Trie 树中的词只可共用前缀，不可共用词的其他部分；例如“中华”、“华人”这两个词虽然前一个词的后缀是后一个词的前缀，但在树形上必须是独立的两条链路，而不可以通过首尾交接构建这两个词，这也说明 Trie 树仅能依靠公共前缀压缩字典的存储空间，并不能共享词中的所有相同的字符；</p></li><li><p>Trie 树中任何一个完整的词，都必须是从根节点开始至叶子节点结束，这意味着对一个词进行检索也必须从根节点开始，至叶子节点才算结束。</p></li><li><p>Trie树特性：</p><p>1）根节点不包含字符，除根节点外每一个节点都只包含一个字符。</p><p>2）从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</p><p>3）每个节点的所有子节点包含的字符都不相同。</p><p>4）如果字符的种数为n，则每个结点的出度为n，这也是空间换时间的体现，浪费了很多的空间。</p><p>5）插入查找的复杂度为O(n)，n为字符串长度。</p></li></ol><h2 id="三、Trie-树的时间复杂度"><a href="#三、Trie-树的时间复杂度" class="headerlink" title="三、Trie 树的时间复杂度"></a>三、Trie 树的时间复杂度</h2><p>在 Trie 树中搜索一个字符串，会从根节点出发，沿着某条链路向下逐字比对字符串的每个字符，直到抵达底部的叶子节点才能确认字符串为该词，这种检索方式具有以下两个优点：</p><p>基本思想（以字母树为例）：</p><ul><li>1、插入过程<br>对于一个单词，从根开始，沿着单词的各个字母所对应的树中的节点分支向下走，直到单词遍历完，将最后的节点标记为红色，表示该单词已插入Trie树。</li><li>2、查询过程<br>同样的，从根开始按照单词的字母顺序向下遍历trie树，一旦发现某个节点标记不存在或者单词遍历完成而最后的节点未标记为红色，则表示该单词不存在，若最后的节点标记为红色，表示该单词存在。</li></ul><p>这两个优点相结合可以最大限度地减少无谓的字符比较，使得搜索的时间复杂度理论上仅与检索词的长度有关：O(K)，其中 K 为检索词的长度。</p><h2 id="四、Trie-树的缺点"><a href="#四、Trie-树的缺点" class="headerlink" title="四、Trie 树的缺点"></a>四、Trie 树的缺点</h2><p>综上可知， Trie 树主要是利用词的公共前缀缩小查词范围、通过状态间的映射关系避免了字符的遍历，从而达到高效检索的目的。这一思想有赖于字符在词中的前后位置能够得到表达，因此其设计哲学是典型的“<strong>以信息换时间</strong>”，当然，这种优势同样是需要付出代价的：</p><ol><li>由于结构需要记录更多的信息，因此 Trie 树的实现稍显复杂。好在这点在大多数情况下并非不可接受。</li><li>Trie 型词典不仅需要记录词，还需要记录字符之间、词之间的相关信息，因此字典构建时必须对每个词和字逐一进行处理，而这无疑会减慢词典的构建速度。对于强调实时更新的词典而言，这点可能是致命的，尤其是采用双数组实现的 Trie 树，更新词典很大概率会造成词典的全部重构，词典构建过程中还需处理各种冲突，因此重构的时间非常长</li></ol><h2 id="五、Trie-树的几种实现"><a href="#五、Trie-树的几种实现" class="headerlink" title="五、Trie 树的几种实现"></a>五、Trie 树的几种实现</h2><h3 id="5-1、Array-Trie-树"><a href="#5-1、Array-Trie-树" class="headerlink" title="5.1、Array Trie 树"></a>5.1、Array Trie 树</h3><p>很多文章里将这种实现称为“标准 Trie 树”，但其实它只是 Trie 众多实现中的一种而已，由于这种实现结构简单，检索效率很好，作为讲解示例很不错，因此特地改称其为“经典 Trie 树”，这里引用一下别人家的示例图[2]：</p><blockquote><p>abc、d、da、dda 四个字符串构成的 Trie 树，如果是字符串会在节点的尾部进行标记。没有后续字符的 branch 分支指向NULL</p><p><img src="https://image-static.segmentfault.com/291/451/2914510947-58d22bd05412f_articlex" alt="img"></p></blockquote><p>如上图，这种实现的特点是：<strong>每个节点都由指针数组存储，每个节点的所有子节点都位于一个数组之中，每个数组都是完全一样的</strong>。对于英文而言，每个数组有27个指针，其中一个作为词的终结符，另外 26 个依次代表字母表中的一个字母，对应指针指向下一个状态，若没有后续字符则指向NULL。由于数组取词的复杂度为O(1)</p><h3 id="5-2、List-Trie-树"><a href="#5-2、List-Trie-树" class="headerlink" title="5.2、List Trie 树"></a>5.2、List Trie 树</h3><p>由于数组的长度是不可变，因此经典 Trie 树存在着明显的空间浪费。但是如果将每一层都换成可变数组（不同语言对这种数据结构称呼不同，比如在 Python 中为List，C# 称为 LinkedList）来存储节点（见下图[3]），每层可以根据节点的数量动态调整数组的长度，就可以避免大量的空间浪费。下图就是这种实现的图例[3]：    </p><p><img src="https://image-static.segmentfault.com/490/222/490222924-58d3381e6c6c5_articlex" alt="clipboard.png"></p><h3 id="5-3、Hash-Trie-树"><a href="#5-3、Hash-Trie-树" class="headerlink" title="5.3、Hash Trie 树"></a>5.3、Hash Trie 树</h3><p>可变数组取词速度太慢，用一组键值对字典类型代替可变数组：其中每个节点包含一组 Key-Value，每个 Key 对应该节点下的一个子节点字符，value 则指向相应的后一个状态。这种方式可以有效的减少空间浪费，同时由于键值对本质上就是一个哈希实现，因此理论上其查词效率也很高（理想状态下取词复杂度为O(1)</p><h3 id="5-4、Double-array-Trie-树"><a href="#5-4、Double-array-Trie-树" class="headerlink" title="5.4、Double-array Trie 树"></a>5.4、Double-array Trie 树</h3><p>双数组 Trie 树是目前 Trie 树各种实现中性能和存储空间均达到很好效果的实现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h2&gt;&lt;h4 id=&quot;212-单词搜索-II&quot;&gt;&lt;a href=&quot;#212-单词搜索-II&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/10/17/PWN%E4%BB%8B%E7%BB%8D/"/>
    <id>http://blog.imlch.cn/2020/10/17/PWN介绍/</id>
    <published>2020-10-17T10:39:10.841Z</published>
    <updated>2020-11-30T02:35:26.338Z</updated>
    
    <content type="html"><![CDATA[<p>Pwn是一个黑客语法的俚语词 ，是指攻破设备或者系统 。发音类似“砰”，对黑客而言，这就是成功实施黑客攻击的声音——砰的一声，被“黑”的电脑或手机就被你操纵。以上是从百度百科上面抄的简介，而我个人理解的话，应该就是向目标发送特定的数据，使得其执行本来不会执行的代码，前段时间爆发的永恒之蓝等病毒其实也算得上是pwn的一种。</p><p>pwnable.kr</p><p>pwnable.tw</p><h2 id="pwn介绍"><a href="#pwn介绍" class="headerlink" title="pwn介绍"></a>pwn介绍</h2><p>CTF pwn中的目标是拿到flag，一般是在linux平台下通过二进制/系统调用等方式编写漏洞利用脚本exp来获取对方服务器的shell，然后get到flag</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>长亭安全：<a href="https://zhuanlan.zhihu.com/p/25816426" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25816426</a></p><h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><ul><li>汇编语言，函数调用约定，大小端，函数栈帧</li><li>python语言，gdb调试，IDA pro分析</li><li>linux相关：32位与64位，各类防护机制（NX，ASLR，Canary，Relro），ELF文件格式，系统调用，shell命令</li><li>编译，链接，装载，执行</li></ul><h2 id="常见漏洞简介"><a href="#常见漏洞简介" class="headerlink" title="常见漏洞简介"></a>常见漏洞简介</h2><ul><li>缓冲区溢出(Buffer overflow)</li><li>栈溢出，堆溢出，bss溢出等</li><li>整数溢出(Integer overflow)</li><li>整数的加减乘法</li><li>有符号与无符号的转换</li><li>整数溢出一般可以转换成其它漏洞</li><li>格式化字符串(Format string)</li><li>printf(s)，sprint f(s)，fprintf(s)可以修改地址也可以用来leak信息</li><li>使用后释放(Use-after-free)</li><li>释放掉的内存可能会被重新分配，释放后使用会导致重新分配的内存被旧的使用所改写</li><li>Double free是一种特殊的UAF</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>IDA</li><li>pro</li><li>gdb</li><li>pwntools</li><li>zio</li><li>peda</li><li>readelf</li><li>ropgadget</li><li>string</li><li>objdump</li></ul><h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><ul><li><p>注入代码 </p></li><li><ul><li>溢出后在栈上执行代码</li></ul></li><li><p>伪造函数 </p></li><li><ul><li>修改.got.plt地址，替换掉正常函数</li><li>布置gadget将ret地址指向libc中的其它函数</li></ul></li></ul><h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><p>如何开始你的CTF之旅</p><p>PWN总结</p><p>p4-team</p><p>uaf</p><p>ddaa</p><p>二进制漏洞学习</p><p>sploitfun</p><p>CTF Writeup Github</p><p>pwnable.kr</p><p>pwnable.tw</p><p>ROPemporium</p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p>《有趣的二进制》<br>《深入理解计算机系统》<br>《程序员的自我修养》<br>《深入理解Linux内核》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Pwn是一个黑客语法的俚语词 ，是指攻破设备或者系统 。发音类似“砰”，对黑客而言，这就是成功实施黑客攻击的声音——砰的一声，被“黑”的电脑或手机就被你操纵。以上是从百度百科上面抄的简介，而我个人理解的话，应该就是向目标发送特定的数据，使得其执行本来不会执行的代码，前段时间
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/10/15/KNN%E7%9A%84%E8%B6%85%E5%8F%82%E6%95%B0/"/>
    <id>http://blog.imlch.cn/2020/10/15/KNN的超参数/</id>
    <published>2020-10-15T15:17:17.312Z</published>
    <updated>2020-11-08T06:51:20.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GRID-SEARCH-网格搜索（KNN算法）寻找最合适的超参数"><a href="#GRID-SEARCH-网格搜索（KNN算法）寻找最合适的超参数" class="headerlink" title="GRID SEARCH 网格搜索（KNN算法）寻找最合适的超参数"></a>GRID SEARCH 网格搜索（KNN算法）寻找最合适的超参数</h2><h2 id="KNN算法的超参数："><a href="#KNN算法的超参数：" class="headerlink" title="KNN算法的超参数："></a>KNN算法的超参数：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br></pre></td></tr></table></figure><p><strong>KNeighborsClassifier 的超参数：</strong></p><p><strong>1. n_neighbors : 表示选择距离最近的K个点来投票的数量。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knn_clf = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><strong>2.weights ：表示最近的K个点中，是否考虑距离的权重；</strong></p><p>weights = uniform （默认）表示不考虑权重</p><p>weighs = distance 表示考虑距离的权重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knn_clf = KNeighborsClassifier(n_neighbors=3 , weights = &apos;distance&apos;)</span><br></pre></td></tr></table></figure><p><strong>3. p ：表示选择的距离类型；只有当 weights = ‘distance’ 时，p才有意义；</strong></p><p>p = 1 表示选择曼哈顿距离</p><p>p = 2 表示选择欧拉距离（默认）</p><p>p &gt;=3 表示选择其他距离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knn_clf = KNeighborsClassifier(n_neighbors=3 , weights = &apos;distance&apos; , p = 1)</span><br></pre></td></tr></table></figure><p><strong>4. KNN算法还有其他超参数，暂时不考虑</strong></p><p>具体可以参考：<a href="http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" target="_blank" rel="noopener">http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html</a></p><h2 id="GRID-SEARCH-网格搜索"><a href="#GRID-SEARCH-网格搜索" class="headerlink" title="GRID SEARCH 网格搜索"></a>GRID SEARCH 网格搜索</h2><p><strong>1. 创建KNN实例，设置需要搜寻的超参数格式，用字典的形式表示</strong></p><p><strong><strong>*字典的键 表示参数的名称 ； 对应的值放在列表中，表示需要搜寻的参数值*</strong></strong></p><p><img src="https://www.freesion.com/images/1/8393acb28450a43af3f02c4d7e585731.png" alt="img"></p><p><strong>2. 用GridSearchCV 来网格搜索</strong></p><p><img src="https://www.freesion.com/images/710/484692939f71989b1c3609b2f032f53e.png" alt="img"></p><p><strong>3. fit 结束后</strong></p><p>调用 .best_estimator_ ，可以返回最佳的分类器</p><p>调用 .best_score_ ， 可以返回最佳分类器对应的准确度</p><p>调用 .best_params_ ，可以返回最佳分类器对应的参数</p><p><img src="https://www.freesion.com/images/683/1792b7676810ed8fc89ba5abccccc453.png" alt="img"></p><p><strong>4. GridsearchCV 中的准确度（score）采用的是交叉验证（Cross-validation）得来的分数；不是通过 test数据集验证；</strong></p><h2 id="其他超参数：N-JOBS-和-VERBOSE"><a href="#其他超参数：N-JOBS-和-VERBOSE" class="headerlink" title="其他超参数：N_JOBS 和 VERBOSE"></a>其他超参数：N_JOBS 和 VERBOSE</h2><p>n_jobs 参数，表示为计算机分配几个核来并行执行搜索 ， n_jobs = -1 表示计算机有几个核就分配几个；</p><p>verbose 参数，表示在搜索的过程中 输出过程， 参数为整数，越大表示输出的内容月详细</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"></span><br><span class="line">grid_search = GridSearchCV(knn_clf,param_grid,n_jobs = <span class="number">-1</span>,verbose=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grid_search.fit(X_train,y_train)</span><br><span class="line">Fitting <span class="number">3</span> folds <span class="keyword">for</span> each of <span class="number">60</span> candidates, totalling <span class="number">180</span> fits</span><br><span class="line">[Parallel(n_jobs=<span class="number">-1</span>)]: Done  <span class="number">17</span> tasks      | elapsed:   <span class="number">10.8</span>s</span><br><span class="line">[Parallel(n_jobs=<span class="number">-1</span>)]: Done  <span class="number">90</span> tasks      | elapsed:   <span class="number">35.6</span>s</span><br><span class="line">Wall time: <span class="number">1</span>min <span class="number">14</span>s</span><br><span class="line">[Parallel(n_jobs=<span class="number">-1</span>)]: Done <span class="number">180</span> out of <span class="number">180</span> | elapsed:  <span class="number">1.2</span>min finished</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GRID-SEARCH-网格搜索（KNN算法）寻找最合适的超参数&quot;&gt;&lt;a href=&quot;#GRID-SEARCH-网格搜索（KNN算法）寻找最合适的超参数&quot; class=&quot;headerlink&quot; title=&quot;GRID SEARCH 网格搜索（KNN算法）寻找最合适
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/10/14/PNPNP_completeP_hard%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.imlch.cn/2020/10/14/PNPNP_completeP_hard问题/</id>
    <published>2020-10-14T13:37:39.921Z</published>
    <updated>2020-10-24T08:02:08.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="P-NP-NP-complete-NP-hard问题"><a href="#P-NP-NP-complete-NP-hard问题" class="headerlink" title="P/NP/NP_complete/NP_hard问题"></a>P/NP/NP_complete/NP_hard问题</h2><p>机器学习面临的问题通常是NP-hard甚至更难，而有效的学习算法必然是在多项式时间内运行完成，若可彻底避免过拟合，则通过经验误差最小化就能获最优解，这就意味着我们构造性地证明了“P=NP”，因此，只要相信“P≠NP”，过拟合就不可避免。</p><p>###定义问题</p><p>P问题、NP问题、NPC问题和NP hard问题，其中P/NP问题是在理论信息学中计算复杂度理论领域里至今未被解决的问题，也是克雷数学研究所七个千禧年大奖难题之一。P/NP问题中包含了复杂度类P与NP的关系：P=NP?</p><ul><li><p>NP类问题，就是不知道这个问题是不是存在多项式时间内的算法，所以叫non-deterministic非确定性，但是我们可以在多项式时间内验证并得出这个问题的一个正确解（TSP问题）</p></li><li><p>P类问题是NP问题的子集，因为存在多项式时间解法的问题，总能在多项式时间内得到验证</p></li><li><p>NP-complete问题是如果所有NP问题可在多项式时间内归约成某个NP问题，则该NP问题称为NP完全问题。</p><p>同时满足两个条件：（1）该问题是一个NP问题；（2）所有NP问题可以归约为该问题。所以NPC问题既是NP问题的子集，又是NP hard问题的子集，因此NPC问题是NP问题和NP hard问题的交集。</p><p>可满足性问题、哈密顿圈问题、巡回售货员问题、最长路径问题都是NPC问题。 装箱(bin packing)问题、背包(knapsack)问题、图的着色(graph coloring)问题以及团(clique)的问题都是著名的NPC问题。</p></li></ul><ul><li><p>NP_Hard指问题S，满足任何NP问题都可以在多项式级时间复杂度内被归约为S（归约：即被归约的NP问题与S的答案相同，当解决了S时，就同时解决了所有的NP问题）。可以理解为，这是一个比所有NP问题都难的问题。</p><p>（NP hard问题不一定是NP问题，有可能是不可判定问题。这时候说明原问题也是不可判定的）</p></li></ul><p>###相互关系</p><p>NP hard问题和NPC问题都要求能够在<strong>多项式时间</strong>内<strong>规约</strong>成另外一个问题。这里<strong>规约</strong>的意思是<strong>将一个特殊问题一般化</strong>，即将原问题推广为一个最一般的、最有概括性、也更难的、计算复杂度更高的问题，这个问题具有最高的计算复杂度，如果这个最一般的问题也能有多项式时间求解算法，那么那些特殊的原问题也能有多项式时间求解算法。</p><ul><li>假设 N P = P 猜想不成立，那么计算复杂度的相对关系为（按照由低到高）：P &lt; N P &lt; N P C &lt; NPhard</li><li>假设 N P = P 猜想成立，那么说明所有存在多项式时间验证算法的问题都存在多项式时间求解算法，而NPC本身属于NP问题，因此NPC也存在多项式时间求解算法，所以NPC = P，所以 P = N P = NPC ，属于NP hard问题的一个子集。</li></ul><p>正是NPC问题的存在，使人们相信P≠NP<br>NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。<br>NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决</p><p>###其他理解</p><ul><li>计算机处理的输入常常不是几十个或几千个，而是几百万个的时候，时间复杂度为O ( n 2 ) O(n^2)<em>O</em>(<em>n</em>2)和O ( e n ) O(e^n)<em>O</em>(<em>e**n</em>)的算法，所需的运行次数简直是天壤之别，O ( e n ) O(e^n)<em>O</em>(<em>e**n</em>)指数级的可能运行好几天都没法完成任务，所以才要研究一个问题是否存在多项式时间算法。</li><li>而我们也只在乎一个问题是否存在多项式算法，因为一个时间复杂度比多项式算法还要复杂的算法研究起来是没有任何实际意义的</li></ul><ul><li>最开始的时候，大家不知道NP的定义是存在所谓 最难的 这么一个东西的，各类问题没有固定的比较标准。直到一个叫Cook的数学家做了点CS的工作，他证明了任何一个NP形式的问题都可以转换成 3SAT （某个NP问题）。3SAT 就是说有n个variable，m个clause，每个clause都是某三个variable 或（|） 在一起， 最后再把所有的clause 和（&amp;） 在一起， 问题是：“有没有一种对于这n个variable的取值可以让整个boolean formula的值为true？” 3SAT 这个问题的优点在于它非常的直观清晰。最开始这篇文章没得到什么重视，直到一个非常出名的计算机科学家Levin看到了这篇文章，突然意识到如果这么多问题都等价于 3SAT 问题，那这就很好地揭示了为什么之前那么多算法问题都找不到快速的（多项式级）算法，因为都和3SAT一样难嘛；另外可以用 3SAT 作为对各种计算问题的分界线，那以后只要发现是NP-complete的问题，大家就不用对于每个问题找解法了。由此衍生了很多对于complexity class的研究，而cook-levin这种把NP问题化为3SAT的思想一次又一次起到了至关重要的作用。</li></ul><p>PS : 时间复杂度</p><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;P-NP-NP-complete-NP-hard问题&quot;&gt;&lt;a href=&quot;#P-NP-NP-complete-NP-hard问题&quot; class=&quot;headerlink&quot; title=&quot;P/NP/NP_complete/NP_hard问题&quot;&gt;&lt;/a&gt;P/NP/NP_
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/10/10/LeetCode485/"/>
    <id>http://blog.imlch.cn/2020/10/10/LeetCode485/</id>
    <published>2020-10-10T11:49:23.820Z</published>
    <updated>2020-10-10T11:49:00.838Z</updated>
    
    <content type="html"><![CDATA[<p>##LeetCode485</p><p>方法一：一次遍历</p><p>算法：</p><p>用一个计数器 count 记录 1 的数量，另一个计数器 maxCount 记录当前最大的 1 的数量。<br>遇到 1 时，count 加一。遇到 0 时：将 count 与 maxCount 比较，maxCoiunt 记录较大值。<br>将 count 设为 0。 返回 max（Count，maxcount)。</p><p>PS :当然也可以在遇到1时候就进行maxcount比较，（从测试用例耗时来看）和前面相比耗时会多一些    ，考虑原因可能是题目是找最大连续1的个数，用例中1比0多的用例占多数，遇到0时再max比较，比较次数会少一些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">       res=<span class="number">0</span></span><br><span class="line">       count=<span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">           <span class="keyword">if</span> nums[i]:</span><br><span class="line">               count+=<span class="number">1</span></span><br><span class="line">               <span class="comment">#res=max(res,count)</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               count=<span class="number">0</span></span><br><span class="line">               res=max(res,count)</span><br><span class="line">       <span class="comment">#return res</span></span><br><span class="line">   retuen max(res,count)</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(N)    N是数组的长度。<br>空间复杂度：O(1)     count 和 maxCount。<br>方法二：<br>使用 splits 函数在 0 处分割将数组转换成字符串。在获取子串的最大长度就是最大连续 1 的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> max(map(len, <span class="string">''</span>.join(map(str, nums)).split(<span class="string">'0'</span>))</span><br></pre></td></tr></table></figure><p>方法三：</p><p>看到评论区有其他语言的双指针法，改写python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        count =<span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">1</span>:</span><br><span class="line">                start =i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        curstart = start </span><br><span class="line">        maxcount = <span class="number">0</span></span><br><span class="line">        count =<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">1</span>:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count&gt;maxcount:</span><br><span class="line">                    maxcount = count</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curstart=i+<span class="number">1</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> maxcount</span><br></pre></td></tr></table></figure><p>如果使用普通的快排划分，虽然时间复杂度是O(n)，空间复杂度是O(1)。</p><p>但是仍然不是最优解。因为普通的快排划分需要对数组进行两次扫描(第一次以2为中心划分，第二次以1为中心划分)。    </p><p>题目要求的最优是对数组进行一次扫描。</p><p>怎么做呢？</p><p>设置两个变量r1,r2，含义是r1,左边(包含r1)的变量值都小于1，r2左边(包含r2)的变量值都小于2。</p><p>那么初始时他俩都是-1(实际上是左边界-1)，代表他俩所包裹的范围是空。</p><p>假设现在有数组nums = [0,0,1,1,2,0,0],r1 = 1,r2 = 3。下一个数组索引i是5，也就是要处理0，这个数是小于2的。</p><p>因此r2+1，代表区间扩大，把nums[i]和nums[r2]交换。此时维持了r2左侧的数都是小于2的这个性质。</p><p>交换完之后，这个小于2的数存放在了nums[r2]，但是这个nums[r2]仍然有可能小于1，若是小于1，那么</p><p>应该把r1+1，代表区间扩大，然后把nums[r1]和nums[r2]交换，这样才能维持r1左侧的数小于1的这个性质。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(nums,i,j)</span>:</span></span><br><span class="line">            temp=nums[i]</span><br><span class="line">            nums[i]=nums[j]</span><br><span class="line">            nums[j]=temp</span><br><span class="line">        r1,r2=<span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range (len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;<span class="number">2</span>:</span><br><span class="line">                r2+=<span class="number">1</span></span><br><span class="line">                swap(nums,i,r2)</span><br><span class="line">                <span class="keyword">if</span> nums[r2]&lt;<span class="number">1</span>:</span><br><span class="line">                    r1+=<span class="number">1</span></span><br><span class="line">                    swap(nums,r1,r2)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##LeetCode485&lt;/p&gt;
&lt;p&gt;方法一：一次遍历&lt;/p&gt;
&lt;p&gt;算法：&lt;/p&gt;
&lt;p&gt;用一个计数器 count 记录 1 的数量，另一个计数器 maxCount 记录当前最大的 1 的数量。&lt;br&gt;遇到 1 时，count 加一。遇到 0 时：将 count 与 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/09/26/LeetCode106/"/>
    <id>http://blog.imlch.cn/2020/09/26/LeetCode106/</id>
    <published>2020-09-26T09:57:11.853Z</published>
    <updated>2020-09-26T10:00:43.478Z</updated>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[9,3,15,20,7]</span><br><span class="line">[9,15,7,20,3]</span><br></pre></td></tr></table></figure><ul><li>1.用L表示左子树，P代表根，R代表右子树</li><li>2.中序序列可表示为 LPR, 后序序列可表示为 LRP</li><li>3.后序序列的最后一个元素是二叉树的根，如3</li><li>4.根据根的值可以把中序序列分为两部分[9]和[3,15,20, 7]</li><li>5.中序两部分元素个数分别为1，4</li><li>6.根据中序元素个数把后续分为两部分[9]和[15, 7, 20, 3]</li><li>7.用中序和后序对应的部分分别创建树的左子树和右子树</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(il, ir, pl, pr)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (il == ir <span class="keyword">or</span> pl == pr):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">            root = TreeNode(postorder[pr<span class="number">-1</span>])</span><br><span class="line">            inRootPos = inorder.index(root.val, il, ir)</span><br><span class="line">            rightSize = ir - inRootPos</span><br><span class="line">            </span><br><span class="line">            root.right = helper(inRootPos + <span class="number">1</span>, ir, pr - rightSize, pr - <span class="number">1</span>)</span><br><span class="line">            root.left = helper(il, inRootPos, pl, pr - rightSize)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, len(inorder), <span class="number">0</span>, len(postorder))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/09/19/LeetCode114/"/>
    <id>http://blog.imlch.cn/2020/09/19/LeetCode114/</id>
    <published>2020-09-19T11:44:23.800Z</published>
    <updated>2020-09-19T12:19:18.682Z</updated>
    
    <content type="html"><![CDATA[<p>###思路</p><p>首先题目的要求是原地</p><ul><li>首先判断是否有root,如果没有则return空值</li><li>接下来将root.left二叉树复制给node，然后开始判断是否有if node,有的话继续判断该节点是否有右子节点while node.right:,如果有右子节点就继续判断node=node.right。</li><li>将根节点的右子节点复制到，刚刚搜索到的那个节点的右子节点node.right=root.right。</li><li>将整个根节点的左子节点覆盖根节点的右子节点root.right=root.left，并将根节点的左子节点重置为None</li><li>最后递归调用，参数为根节点的右子节点root.right，也就是现在root.right作为新的root根节点，之后的每次递归调用都更新根节点。</li></ul><p>###具体代码以及注释如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span>       </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 后序遍历</span></span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">            <span class="comment"># 寻找root.left尾部用的指针</span></span><br><span class="line">            index = root.left</span><br><span class="line">            <span class="comment"># while循环找root.left的尾部</span></span><br><span class="line">            <span class="keyword">while</span> index.right:</span><br><span class="line">                index=index.right</span><br><span class="line">            <span class="comment"># 进行拼接工作</span></span><br><span class="line">            index.right = root.right</span><br><span class="line">            root.right=root.left</span><br><span class="line">            root.left=<span class="keyword">None</span></span><br><span class="line">            <span class="comment"># 如果没有左节点，就不用拼接了</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.left:</span><br><span class="line">            root.right=root.left</span><br><span class="line">            root.left=<span class="keyword">None</span></span><br></pre></td></tr></table></figure><h3 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1.前序遍历"></a><strong>1.前序遍历</strong></h3><p>前序遍历执行的是中左右的遍历原则，即先遍历中间的根节点，然后左节点，最后右节点。这样获得的遍历顺序为：1245367</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    tree = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> </span><br><span class="line">        tree.append(node.val)</span><br><span class="line">        helper(node.left)</span><br><span class="line">        helper(node.right)</span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a><strong>2.中序遍历</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerorderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    tree = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> </span><br><span class="line">        helper(node.left)</span><br><span class="line">        tree.append(node.val)</span><br><span class="line">        helper(node.right)</span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a><strong>3.后序遍历</strong></h3><p>后序遍历执行的是左右中的遍历原则，即先遍历中间的左节点，然后右节点，最后中节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    tree = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> </span><br><span class="line">        helper(node.left)</span><br><span class="line">        helper(node.right)</span><br><span class="line">        tree.append(node.val)</span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><h3 id="4-总结规律"><a href="#4-总结规律" class="headerlink" title="4.总结规律"></a>4.总结规律</h3><p>基于以上代码可见，二叉树的遍历基本的代码框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Traversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    tree = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">        <span class="comment">#判断当前节点是否为空</span></span><br><span class="line">        <span class="comment">#执行当前节点操作</span></span><br><span class="line">        <span class="comment">#执行左右子树操作</span></span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><p>1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###思路&lt;/p&gt;
&lt;p&gt;首先题目的要求是原地&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先判断是否有root,如果没有则return空值&lt;/li&gt;
&lt;li&gt;接下来将root.left二叉树复制给node，然后开始判断是否有if node,有的话继续判断该节点是否有右子节点while n
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/09/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%A3%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
    <id>http://blog.imlch.cn/2020/09/19/二叉树解题模板/</id>
    <published>2020-09-19T11:22:03.869Z</published>
    <updated>2020-09-19T12:21:33.312Z</updated>
    
    <content type="html"><![CDATA[<p>##二叉树基本定义</p><p>​    <img src="https://upload-images.jianshu.io/upload_images/7043118-7c9318a6f5c1349d.png?imageMogr2/auto-orient/strip|imageView2/2/w/652/format/webp" alt="img"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1）每个结点最多有两颗子树<br>2）左子树和右子树是有顺序的，次序不能任意颠倒。<br>3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树</p><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#判断当前节点是否为空</span></span><br><span class="line"><span class="comment">#执行当前节点操作</span></span><br><span class="line"><span class="comment">#执行左右子树操作</span></span><br></pre></td></tr></table></figure><h3 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1.前序遍历"></a><strong>1.前序遍历</strong></h3><p>前序遍历执行的是中左右的遍历原则，即先遍历中间的根节点，然后左节点，最后右节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    tree = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> </span><br><span class="line">        tree.append(node.val)</span><br><span class="line">        helper(node.left)</span><br><span class="line">        helper(node.right)</span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a><strong>2.中序遍历</strong></h3><p>中序遍历执行的是左中右的遍历原则，即先遍历中间的左节点，然后中间节点，最后右节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerorderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    tree = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> </span><br><span class="line">        helper(node.left)</span><br><span class="line">        tree.append(node.val)</span><br><span class="line">        helper(node.right)</span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a><strong>3.后序遍历</strong></h3><p>后序遍历执行的是左右中的遍历原则，即先遍历中间的左节点，然后右节点，最后中节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    tree = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> </span><br><span class="line">        helper(node.left)</span><br><span class="line">        helper(node.right)</span><br><span class="line">        tree.append(node.val)</span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><h3 id="4-总结规律"><a href="#4-总结规律" class="headerlink" title="4.总结规律"></a>4.总结规律</h3><p>基于以上代码可见，二叉树的遍历基本的代码框架如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Traversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    tree = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node)</span>:</span></span><br><span class="line">        <span class="comment">#判断当前节点是否为空</span></span><br><span class="line">        <span class="comment">#执行当前节点操作</span></span><br><span class="line">        <span class="comment">#执行左右子树操作</span></span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##二叉树基本定义&lt;/p&gt;
&lt;p&gt;​    &lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7043118-7c9318a6f5c1349d.png?imageMogr2/auto-orient/strip|
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/09/12/ServerlessSSR/"/>
    <id>http://blog.imlch.cn/2020/09/12/ServerlessSSR/</id>
    <published>2020-09-12T10:29:19.638Z</published>
    <updated>2020-09-05T11:50:26.578Z</updated>
    
    <content type="html"><![CDATA[<p>Serverless架构是近年来迅速兴起的一个技术概念。基于这种架构能构建出多种应用场景，适用于各行各业。只要是对轻计算、高弹性、无状态等场景有诉求，您都可以通过本文来熟悉一些基础概念，并从相关场景中获得启发。</p><h2 id="Serverless演进"><a href="#Serverless演进" class="headerlink" title="Serverless演进"></a>Serverless演进</h2><p>关于Serverless架构的演进，网上比较流行用一张人类形态发展史图进行说明。从爬行猿人到蹲着的类猿人，再到直立人类，最后到使用工具的新兴人类。</p><p>人类的每一次进化都伴随着生产效率的提升。同理，整个IT计算的发展历程，也是一个逐步提高生产效率的历程，具体演进图如下所示。<a href="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/5348381951/p6787.png" target="_blank" rel="noopener"><img src="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/5348381951/p6787.png" alt="img"></a></p><p>在这个发展历程中有以下几个渐进的里程碑事件：</p><ol><li>通过虚拟化技术将大型物理机虚拟成单个的VM资源。</li><li>将虚拟化集群搬到云计算平台上，只做简单运维。</li><li>把每一个VM按照运行空间最小化的原则切分成更细的Docker容器。</li><li>基于Docker容器构建不用管理任何运行环境、仅需编写核心代码的Serverless架构。</li></ol><p>因此，这个发展历程也是一场IT架构的演进，期间经历了一系列代际的技术变革，把资源切分得更细，让运行效率更高，让硬件软件维护更简单。IT架构的演进主要有以下几个特点：</p><ul><li>硬件资源使用颗粒度变小</li><li>资源利用率越来越高</li><li>运维工作逐步减少</li><li>业务更聚焦在代码层面</li></ul><p><strong>Serverless架构主要有以下特点：</strong></p><ul><li>实现了细粒度的计算资源分配。</li><li>不需要预先分配资源。</li><li>具备真正意义上的高度扩容和弹性。</li><li>按需使用，按需计费。</li></ul><p>根据Serverless的这些通用特点，归纳出下面几种典型使用场景，供大家参考。</p><h2 id="Serverless的典型应用有哪些？"><a href="#Serverless的典型应用有哪些？" class="headerlink" title="Serverless的典型应用有哪些？"></a>Serverless的典型应用有哪些？</h2><p><strong>事件请求场景</strong></p><ul><li><p>定制图片</p><p>网店店家进行商品图片维护时，需要根据商品陈列位置，将图片动态切割成不同尺寸，或者打上不同水印。当店家把图片上传到<a href="https://www.aliyun.com/product/oss" target="_blank" rel="noopener">对象存储 OSS</a>上，会通过<a href="https://www.aliyun.com/product/fc" target="_blank" rel="noopener">函数计算</a>上定制的trigger来触发函数计算。根据计算规则，生成不同尺寸的图片，满足在线商品陈列需求，整个过程无需再搭建额外服务器，也无需网站美工干预。</p></li><li><p>物联网中的低频请求</p><p>物联网行业中，物联网设备传输数据量小，且往往是以固定时间间隔进行数据传输，因此经常涉及低频请求场景。例如：物联网应用程序每分钟仅运行一次，每次运行 50ms，这意味着CPU的使用率仅为 0.1%/小时，或者说有 1000 个相同的应用可以共享计算资源。而Serverless架构下，用户可以购买每分钟 100ms 的资源来满足计算需求，既能有效解决效率问题，也能降低使用成本。</p></li><li><p>定制事件</p><p>用户注册时发邮件验证邮箱地址，同样可以通过定制的事件来触发后续的注册流程，而无需再配置额外的应用无服务器来处理后续的请求。</p></li><li><p>固定时间触发</p><p>事件触发固定时间触发，例如在夜间或者服务空闲时间来处理繁忙时候的交易数据，或者运行批量数据，来生成数据报表，通过Serverless方式，不用再额外购买利用率并不高的处理资源。</p></li></ul><p><strong>流量突发场景</strong></p><ul><li><p>弹性扩展应对突发流量</p><p>移动互联网应用经常会面对突发流量场景。例如：移动应用的通常流量情况是 QPS 20，但每隔 5 分钟会有一个持续 10s 的 QPS 200 流量（10 倍于通常流量）。传统架构下，企业必须扩展 QPS 200 的硬件能力来应对业务高峰，即使高峰时间仅占整个运行时间的4%。</p><p>在Serverless架构下，您可以利用弹性扩展特性，快速构建新的计算能力来满足当前需求，当业务高峰后，资源能够自动释放，有效节省成本。</p></li><li><p>转码和流量扩容</p><p>视频直播某次专场活动，由于无法预估会有多少点播的观众视频接入，把转码和流量扩容这部分内容通过Function来处理，无需考虑并发和流量扩容。</p></li></ul><p><strong>处理大数据场景</strong></p><p>由于安全审计问题，您需要从OSS（多个地域）过去一年的数据（1 个小时一个文件）中找出特定关键字访问的日志，同时做聚合运算（计算出总值）。如果使用阿里云函数计算，您将高峰期每 2 小时的访问日志，或者低谷期每 4 小时的访问日志交给一个计算函数处理，并将处理结果存到RDS中。使用一个函数分派数据给另一个函数，使其执行成千上万个相同的实例。</p><p>这样会同时运行近千个计算函数（24 x 365 / 10），在不到一分钟的时间内完成整个工作。同样的事情交给ECS+计算脚本来做计算，单单为这些instance配置网络就让人头疼（不同地域无法走内网下载OSS文件）：instance的数量可能已经超出了子网中剩余IP地址的数量（比如，您的VPC使用了24位掩码）。</p><p>下面结合阿里云的函数计算产品来讲解各个应用场景中地架构以及如何解决场景中的痛点。阿里云的函数计算是基于Serverless这种架构实现的一个全托管产品，用户只需要上传核心代码到函数计算，就可以通过事件源或者SDK&amp;API来运行代码。函数计算会准备好运行环境，并根据请求峰值来动态扩容运行环境。函数计算是按照执行时间来计费，请求处理完成后，计费停止，对于有业务请求有明显高峰和低谷的应用来说，相对节省成本。</p><p>下图是函数计算的一个开发者试用操作流程：<a href="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/5348381951/p6791.png" target="_blank" rel="noopener"><img src="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/5348381951/p6791.png" alt="img"></a></p><ol><li>开发者编写代码，目前支持的语言Java、NodeJS、Python等语言。</li><li>把代码上传到函数计算上，上传的方式有通过API或者SDK上传，也可以通过控制台页面上传上传，还可以通过命令行工具Fcli上传。</li><li>通过API&amp;SDK来触发函数计算执行，同样也可以通过云产品的事件源来触发函数计算执行。</li><li>函数计算在执行过程中，会根据用户请请求量动态扩容函数计算来保证请求峰值的执行，这个过程对用户是透明无感知的。</li><li>函数执行结束后，可以通过账单来查看执行费用，根据函数的实际执行时间按量计费，收费粒度精确到100ms。</li></ol><p>讲解完上面的流程后，下面会详细讲解3个Serverless的应用场景，通过案例分享能让您对Serverless这种架构有更清晰的认识。</p><h2 id="场景一：事件触发计算能力"><a href="#场景一：事件触发计算能力" class="headerlink" title="场景一：事件触发计算能力"></a>场景一：事件触发计算能力</h2><p><a href="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/5348381951/p6793.png" target="_blank" rel="noopener"><img src="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/5348381951/p6793.png" alt="img"></a></p><p><strong>场景描述</strong></p><p>用户通过手机终端、Web应用、或者PC工具把各种文件包括图片、视频以及文本等上传到OSS（对象存储，下同）后，利用OSS的PutObject事件可以触发函数计算对上传后的文件进行处理。</p><p><strong>典型场景</strong></p><p>当用户把视频文件上传到OSS后，触发函数计算把对象的Meta信息获取并传输给核心算法库，核心算法库根据算法把相应的视频文件推送CDN源站，达到特定视频热加载的处理。另外一个场景，视频文件上传到OSS后也同时触发函数计算同步做多转码率的处理，并把处理后的视频文件存储到OSS中，完成轻量的数据处理。</p><p>在多媒体的处理场景中，经常会碰到海量文件上传到OSS后，还需要对文件进行进一步的加工，例如加水印、转码率、获取文件属性等操作，这个场景中，用户在处理的时候会遇到以下需要解决的技术难点：</p><ul><li>如何接收文件上传后的动作事件，通常的做法是定制消息通道来接收OSS事件通知，搭建一个运行环境，并编写相关的代码来处理事件通知。</li><li>如何高效的处理完海量上传的文件。</li><li>如何无缝的把多个云产品连接起来。</li></ul><p>通过函数计算能比较方便解决以上几个技术难点：</p><ul><li>函数计算可以设置OSS的触发器来接收事件通知，在函数计算中编写业务代码来处理文件，并通过内网把文件传输到OSS中，整个流程简单易用可扩展。</li><li>可以把核心代码部署到函数计算中，通过函数计算来并发处理事件通知。</li><li>函数计算目前打通了多款产品的内部交互，通过控制台简单配置就可以高效的解决产品间连接问题。</li></ul><p><strong>事件触发场景常规做法：</strong></p><ul><li>设置消息通道接收事件，并编写业务代码。</li><li>购买服务器资源做后端数据处理。</li><li>设计一套多并发框架完成业务上传文件峰值的处理。</li><li>开通多个产品，并调用SDK代码来完成业务交互。</li></ul><p><strong>函数计算解法：</strong></p><ul><li>在控制台上配置事件源通知，编写业务代码。</li><li>代码写到函数计算里，不需要管理软硬件环境。</li><li>业务高峰期函数计算会动态伸缩，无需管理。</li><li>内置打通多款产品，简单配置就可以无缝对接。</li></ul><h2 id="场景二：利用弹性扩容（视频直播多人连麦场景）"><a href="#场景二：利用弹性扩容（视频直播多人连麦场景）" class="headerlink" title="场景二：利用弹性扩容（视频直播多人连麦场景）"></a>场景二：利用弹性扩容（视频直播多人连麦场景）</h2><p><a href="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/6348381951/p6794.png" target="_blank" rel="noopener"><img src="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/6348381951/p6794.png" alt="img"></a></p><p><strong>场景描述</strong></p><p>直播间的客户端把主播和连麦观众的音视频采集发送给函数计算做混流服务，函数计算把数据汇集后交给混流服务进行合成，并把合成画面视频流推送给CDN，终端观众实时拉取直播流，能实时看到混流合成画面。</p><p>视频直播应用场景中，有一种场景视频直播的多人连麦，主播可以同时和多个工作进行连麦，把多个观众或者好友画面接入，并把画面合成到一个场景中，供给更多观看直播的观众观看。这个场景中，有几个技术难度需要关注：</p><ul><li>连麦的观众不固定，需要考虑适度的并发和弹性。</li><li>直播不可能 24 小时在线，有较为明显的业务访问高峰期和低谷期。</li><li>直播是事件或者公众点爆的场景，更新速度较快，版本迭代较快，需要快速完成对新热点的技术升级。</li></ul><p>综合以上几个特点，可以通过Serverless这种架构来完美地解决以上痛点。</p><p>函数计算作为连麦观众和主播接入的实时音频和视频转发集群，当并发量过来时，函数计算自动扩容多个执行环境来处理实时数据流；当业务高峰期过去后，会适度缩减资源使用。代码管理部署在云端，代码迭代可以随时进行修改和维护，无需再多管理一套软件运行环境。</p><p><strong>视频直播场景常规做法：</strong></p><ul><li>购买负载均衡应付并发。</li><li>购买计算资源做数据处理。</li><li>业务低谷期需要想办法释放硬件资源来节省成本。</li><li>多版本要维护多套运行环境。</li></ul><p><strong>函数计算解法：</strong></p><ul><li>把负载分发程序写到函数里。</li><li>多版本迭代无需更换运行环境，仅仅替换代码版本即可。</li><li>业务访问按需付费，业务低谷期无费用。</li></ul><h2 id="场景三：物联网数据处理场景"><a href="#场景三：物联网数据处理场景" class="headerlink" title="场景三：物联网数据处理场景"></a>场景三：物联网数据处理场景</h2><p><a href="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/7348381951/p6796.png" target="_blank" rel="noopener"><img src="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/7348381951/p6796.png" alt="img"></a></p><p>整个架构图分成 2 部分内容：</p><ul><li>Web应用：模拟一个社交内容更新和数据处理的流程，Web用户通过API网关把请求转发到函数计算进行处理，函数计算把处理后的内容更新到数据库中，并更新索引，另外一个函数计算把索引更新推送的搜索引擎供给外部客户进行检索，完成整个数据闭环处理。</li><li>智能设备：通过IoT网关把设备状态推送到函数计算处理，函数计算通过API接口把消息通过移动推送服务，推送给移动端进行状态确认和管理。</li></ul><p>在智能设备状态处理的场景中，同样也会碰到几个核心技术问题要解决。当海量设备把状态发送到IoT平台后，如何设计一套高效非轮询的技术框架来处理设备状态数据；如何把处理后的数据高效透传其他产品，例如写数据库或者推送给移动端。</p><p><strong>IoT设备状态场景常规做法：</strong></p><ul><li>设置消息通道接收事件，并编写业务代码。</li><li>购买服务器资源做后端数据处理。</li><li>开通多个产品，并调用SDK代码来完成业务交互。</li><li>维护相关硬件软件环境。</li></ul><p><strong>函数计算解法：</strong></p><ul><li>定制IoT平台的事件通知，直接把业务代码写到函数计算中。</li><li>不需要维护运行环境，用完即可释放。</li><li>控制台配置，就可以把信息透传给相关产品。</li></ul><p>通过 2 种方式的对比，能看出函数计算的解法更具备通用性，可以大量减少维护工作。</p><h2 id="场景四：共享派单系统详解"><a href="#场景四：共享派单系统详解" class="headerlink" title="场景四：共享派单系统详解"></a>场景四：共享派单系统详解</h2><p>客户通过派单平台选择某种商家提供的服务，可能是餐饮、商品、或者服务。派单平台通知最近的骑手到最近的商家拿到服务并派送到客户手里。一个简单的流程图如下：<a href="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/7348381951/p6797.png" target="_blank" rel="noopener"><img src="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/7348381951/p6797.png" alt="img"></a></p><p><strong>流程详解：</strong></p><ol><li>客户通知派单平台下单某商品。</li><li>派单平台通知最新骑手。</li><li>派单平台同时通知商家商品售卖出去。</li><li>骑手到指定的商家获取商品。</li><li>骑手配送到客户所在地。</li></ol><p><strong>这个派单场景中，要解决几个棘手的技术：</strong></p><ul><li>整合多种资源，计算资源会涉及到，骑手位置信息、最优路径规划、车况情况、调度系统等。</li><li>低延迟：派单系统对订单的响应要求很高，从接单到商家在到客户，整个闭环都需要在段时间内完成。</li><li>海量数据：涉及到三方面的数据，客户数据、商家数据、平台骑手数据、位置信息、商品信息等。</li><li>请求明显波峰波谷：派单系统在一天中的资源使用非常不均衡，波峰期，例如外卖，在中午和晚饭达到高峰，平时空闲。</li></ul><p>通过技术选型转化成阿里云产品的解决方案后，函数计算结合其他产品比较完美地解决上述问题，解决方案如下图所示：</p><p><a href="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/8348381951/p6798.png" target="_blank" rel="noopener"><img src="https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/8348381951/p6798.png" alt="img"></a></p><p><strong>流程详解：</strong></p><ol><li><p>客户APP把订单请求通过API网关透传给函数计算。</p></li><li><p>函数计算把处理后的数据传输给表格存储。</p></li><li><p>表格存储存放了骑行数据、商家信息、位置信息等。</p><p><strong>说明</strong> 其中骑行日志会存放到日志服务里，便于后续做报表分析。骑行过程中骑手头像、随手拍街景会存放到OSS中，骑手位置可以通过函数计算去拉取第三方地图信息，例如高德地图等。</p></li></ol><p>这个方案中，函数计算可以完成动态扩容问题，API网关可以解决鉴权和安全访问问题，函数计算打通了多款产品，可以无缝使用其他资源和内容。所有处理后的数据可以存放到表格存储数据库中，所有日志都可以直接加载到日志服务为后续数据报表服务。</p><p><strong>共享派单系统常规做法：</strong></p><ul><li>购买多台服务器来支持高峰期的访问，访问波谷期自行设置释放原则。</li><li>通过编程方式完成多个产品的交互。</li><li>为了保证负载均衡，需要购买相关的产品来支撑。</li><li>维护相关硬件软件环境。</li></ul><p><strong>函数计算解法：</strong></p><ul><li>定制IoT平台的事件通知，直接把业务代码写到函数计算中。</li><li>不需要维护运行环境，用完即可释放。</li><li>控制台配置，就可以把信息透传给相关产品。</li><li>2种解法都能达到目标，从资源利用率和可维护性来看，使用Serverless架构的方式会更优。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面几个场景的详解，大致可以得出这样的结论：通过事件触发场景；有业务访问高峰和低谷的场景，迭代次数较多，需要快速打通多款产品场景；通过函数计算能完美地解决成本、效率、联通等问题。</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">函数计算</th><th style="text-align:left">自建计算环境</th></tr></thead><tbody><tr><td style="text-align:left">维护性</td><td style="text-align:left">内置打通API网关，OSS，Table Store、IoThub、Log Service、Message Service、Datahub等产品，只需要简单配置。沙箱执行环境，无需配置。自动伸缩和负载均衡。触发条件简单，入口多。</td><td style="text-align:left">多款产品链接需要自己编写代码来实现，有技术门槛。自建物理环境，需要配置运行环境，消耗人力物力。需要自行搭建伸缩机制和负载均衡，耗时较多。</td></tr><tr><td style="text-align:left">可靠性</td><td style="text-align:left">代码和配置存放在OSS中，自动多重冗余备份。</td><td style="text-align:left">受限于硬件可靠性，易出问题，一旦出现运行环境或者数据损坏，容易出现不可逆转的数据丢失。人工数据恢复困难、耗时、耗力。</td></tr><tr><td style="text-align:left">成本</td><td style="text-align:left">按执行付费，在业务请求波谷期费用低廉。上行流量免费无需运维人员和托管费用阿里云产品内部传输无费用同比计算能力，成本节省1/3</td><td style="text-align:left">业务请求的波峰需要资源扩容，波谷的时候资源浪费。需要专人维护运行环境和硬件资源，人力成本较高。产品之间联通如果走公网，需要额外支付流量费用。</td></tr><tr><td style="text-align:left">安全</td><td style="text-align:left">沙箱运行在阿里云企业级别安全环境里。多用户运行是服务器级别隔离机制。提供多种服务授权和子主账号。</td><td style="text-align:left">需要另外购买清洗和黑洞设备需要单独实现安全访问机制。</td></tr></tbody></table><p>函数计算虽然适用于很多场景，但也不是覆盖全部应用场景的万金油。例如某些业务在一天中没有明显的请求波峰波谷，请求相对平缓，那么使用函数计算成本不见得会节省多少。</p><p>Serverless框架作为新兴的技术，目前相应的支持开发工具较少，整体框架还在探索中。另外，函数计算的执行环境是不记录状态的，有些耦合性较强的应用也不太适合用Serverless这种框架。受限于资源大小分配，一些大型的应用程序也不太容易能拆分搬上来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Serverless架构是近年来迅速兴起的一个技术概念。基于这种架构能构建出多种应用场景，适用于各行各业。只要是对轻计算、高弹性、无状态等场景有诉求，您都可以通过本文来熟悉一些基础概念，并从相关场景中获得启发。&lt;/p&gt;
&lt;h2 id=&quot;Serverless演进&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/09/05/Note200829/"/>
    <id>http://blog.imlch.cn/2020/09/05/Note200829/</id>
    <published>2020-09-05T10:12:11.131Z</published>
    <updated>2020-10-29T12:38:20.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h2><p>xpath如何取包含多个class属性</p><p>但是如果html是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div class="test demo"&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test demo2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果目标 class 不一定是第一个，那么：</p><blockquote><p>//div[contains(concat(‘ ‘, @class, ‘ ‘), ‘demo’)]     ##只想选出有demo这个class的对象</p></blockquote><p>取多个class属性值的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'a b'</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以用如下的表达式：</p><blockquote><p>xpath(‘//div[contains(@class,”a”)]’)  #它会取得所有class为a的元素</p></blockquote><blockquote><p>xpath(‘//div[contains(@class,”a”) and contains(@class,”b”)]’) #它会取class同时有a和b的元素</p></blockquote><p>##应对反爬虫措施解决方案</p><h3 id="user-agent-伪装和轮换"><a href="#user-agent-伪装和轮换" class="headerlink" title="user_agent 伪装和轮换"></a>user_agent 伪装和轮换</h3><p>不同浏览器的不同版本都有不同的user_agent，是浏览器类型的详细信息，也是浏览器提交Http请求的重要头部信息。我们可以在每次请求的时候提供不同的user_agent，绕过网站检测客户端的反爬虫机制。比如说，可以把很多的user_agent放在一个列表中，每次随机选一个用于提交访问请求。有一个提供各种user_agent的网站：</p><p><a href="http://www.useragentstring.com/" target="_blank" rel="noopener">http://www.useragentstring.com/</a></p><p>最近又看到一个专门提供伪装浏览器身份的开源库，名字取得很直白：</p><p><a href="https://github.com/hellysmile/fake-useragent" target="_blank" rel="noopener">fake-useragent</a></p><h3 id="使用代理IP和轮换"><a href="#使用代理IP和轮换" class="headerlink" title="使用代理IP和轮换"></a>使用代理IP和轮换</h3><p>检查ip的访问情况是网站的反爬机制最喜欢也最喜欢用的方式。这种时候就可以更换不同的ip地址来爬取内容。当然，你有很多有公网ip地址的主机或者vps是更好的选择，如果没有的话就可以考虑使用代理，让代理服务器去帮你获得网页内容，然后再转发回你的电脑。代理按透明度可以分为透明代理、匿名代理和高度匿名代理:</p><ul><li><strong>透明代理</strong>：目标网站知道你使用了代理并且知道你的源IP地址，这种代理显然不符合我们这里使用代理的初衷</li><li><strong>匿名代理</strong>：匿名程度比较低，也就是网站知道你使用了代理，但是并不知道你的源IP地址</li><li><strong>高匿代理</strong>：这是最保险的方式，目标网站既不知道你使用的代理更不知道你的源IP<br>代理的获取方式可以去购买，当然也可以去自己爬取免费的，<a href="http://www.xicidaili.com/nn/" target="_blank" rel="noopener">这里</a>有一个提供免费代理的网站，可以爬下来使用，但是免费的代理通常不够稳定。</li></ul><h3 id="设置访问时间间隔"><a href="#设置访问时间间隔" class="headerlink" title="设置访问时间间隔"></a>设置访问时间间隔</h3><p>很多网站的反爬虫机制都设置了访问间隔时间，一个IP如果短时间内超过了指定的次数就会进入“冷却CD”，所以除了轮换IP和user_agent<br>可以设置访问的时间间间隔长一点，比如没抓取一个页面休眠一个随机时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time，random</span><br><span class="line">time.sleep(random.random()*<span class="number">3</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Xpath&quot;&gt;&lt;a href=&quot;#Xpath&quot; class=&quot;headerlink&quot; title=&quot;Xpath&quot;&gt;&lt;/a&gt;Xpath&lt;/h2&gt;&lt;p&gt;xpath如何取包含多个class属性&lt;/p&gt;
&lt;p&gt;但是如果html是&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/08/29/LeetCode101/"/>
    <id>http://blog.imlch.cn/2020/08/29/LeetCode101/</id>
    <published>2020-08-29T10:09:34.691Z</published>
    <updated>2020-08-29T10:21:23.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p><img src="https://pic.leetcode-cn.com/7f7978d0887dc8059d7058ebd60333160ab3fd0a7de39cbf559edec319ba6c49-image-20200514180949390.png" alt="image-20200514180949390.png"></p><p>###思路—分治法</p><p>如果满足条件的对称二叉树</p><p>其左子树的前序遍历  &amp;&amp;  右子树的后序遍历 </p><p>得到的列表必然完全相反</p><p>左子树进行前序遍历: pre_order = [2,3,5,6,4,7,8]       后序遍历：post_order = [8,7,4,6,5,3,2]</p><p>pre==post.reverse</p><p>###代码</p><ul><li>按照总结的二叉树遍历模板</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分别定义前序和后序遍历的函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_order</span><span class="params">(self,root,li)</span>:</span>    <span class="comment"># 二叉树的前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        li.append(root.val)</span><br><span class="line">        self.pre_order(root.left,li)</span><br><span class="line">        self.pre_order(root.right,li)</span><br><span class="line">    <span class="keyword">elif</span> root == <span class="keyword">None</span>:</span><br><span class="line">        li.append(<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_order</span><span class="params">(self,root,li)</span>:</span>   <span class="comment"># 二叉树的后序遍历</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        self.post_order(root.left,li)</span><br><span class="line">        self.post_order(root.right,li)</span><br><span class="line">        li.append(root.val)</span><br><span class="line">    <span class="keyword">elif</span> root == <span class="keyword">None</span>:</span><br><span class="line">        li.append(<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        pre = []     <span class="comment"># 用来存左子树的前序遍历</span></span><br><span class="line">        post = []     <span class="comment"># 用来存右子树的后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:   <span class="comment"># 无根节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>:  <span class="comment"># 只有根节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">            self.pre_order(root.left, pre)</span><br><span class="line">            self.post_order(root.right, post)</span><br><span class="line">            post.reverse()            <span class="comment"># 将后序遍历的列表倒序</span></span><br><span class="line">            <span class="keyword">if</span> pre == post:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对称二叉树&quot;&gt;&lt;a href=&quot;#对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;对称二叉树&quot;&gt;&lt;/a&gt;对称二叉树&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://pic.leetcode-cn.com/7f7978d0887dc8059d70
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/08/23/yield/"/>
    <id>http://blog.imlch.cn/2020/08/23/yield/</id>
    <published>2020-08-23T10:25:30.539Z</published>
    <updated>2020-08-23T16:30:52.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键字yield"><a href="#关键字yield" class="headerlink" title="关键字yield"></a>关键字yield</h2><p>首先直观上等价于return，其次可看作生成器的一部分，（带有yield的函数，会被解释器视为一个迭代器，返回iterable对象）</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fab</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">        self.max = max</span><br><span class="line">        self.n, self.a, self.b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.n &lt; self.max:</span><br><span class="line">            r = self.b</span><br><span class="line">            self.a, self.b = self.b, self.a + self.b</span><br><span class="line">            self.n = self.n + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">raise</span> StopIteration()</span><br></pre></td></tr></table></figure><ul><li>判断函数是否为特殊的 generator 函数—isgeneratorfunction</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关键字yield&quot;&gt;&lt;a href=&quot;#关键字yield&quot; class=&quot;headerlink&quot; title=&quot;关键字yield&quot;&gt;&lt;/a&gt;关键字yield&lt;/h2&gt;&lt;p&gt;首先直观上等价于return，其次可看作生成器的一部分，（带有yield的函数，会被解释器视
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/08/20/Timsort/"/>
    <id>http://blog.imlch.cn/2020/08/20/Timsort/</id>
    <published>2020-08-20T12:20:40.877Z</published>
    <updated>2020-08-22T12:09:19.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sort-和sorted"><a href="#sort-和sorted" class="headerlink" title="sort()和sorted()"></a>sort()和sorted()</h2><p>区别介绍</p><ul><li><p>sort 是应用在 list 上的方法，针对原list排序无返回值</p></li><li><p>sorted 是内建函数，可对所有可迭代的对象进行排序操作，会返回新的list</p></li></ul><h2 id="内部实现探究"><a href="#内部实现探究" class="headerlink" title="内部实现探究"></a>内部实现探究</h2><ol><li><p><a href="https://www.zhihu.com/question/36280272" target="_blank" rel="noopener">（知乎）python sort 函数采用的排序算法</a> ：其中一个回答提到了 python 中的 sorted 排序内部实现是 timsort，并没有说 sort 。</p></li><li><p><a href="https://github.com/qiwsir/algorithm/commit/68f1af0cfe3df4a96abc528cd324f5f69f4eb9df" target="_blank" rel="noopener">（GitHub）python的sorted排序分析</a> ： 同样只提到了 python 中的 sorted 排序内部实现是 timsort，并没有说 sort （知乎回答的一个链接）。</p></li><li><p>（CSDN）<a href="https://blog.csdn.net/liusarazhang/article/details/52797328" target="_blank" rel="noopener">C++，java,Python的内部实现sort怎么实现的</a> ：内容提到 python内部的sort采用的是混合（hybrid）排序，规模小的时候采用 <a href="https://blog.csdn.net/caroline_wendy/article/details/24001053" target="_blank" rel="noopener">binary insertion</a>，规模大的时候采用 <a href="https://en.wikipedia.org/wiki/Samplesort" target="_blank" rel="noopener">sample sort</a> 。</p></li></ol><p>###结论：实现机制—Timsort  时间复杂度O(nlogn)     空间复杂度O（n）</p><h2 id="Timsort"><a href="#Timsort" class="headerlink" title="Timsort"></a>Timsort</h2><p> Timsort是结合了合并排序（merge sort）和插入排序（insertion sort）的排序算法，由Tim Peters在2002年设计了该算法并在Python中使用（TimSort 是 Python 中 list.sort 的默认实现）。Pyhton自从2.3版以来一直采用Timsort算法排序，现在Java SE7和Android也采用Timsort算法</p><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>基本工作过程是：</p><ul><li>扫描数组，确定其中的单调上升段和严格单调下降段，将严格下降段反转。我们将这样的段称之为run。</li><li>定义最小run长度，短于此的run通过插入排序合并为长度高于最小run长度；</li><li>反复归并一些相邻run，过程中需要避免归并长度相差很大的run，直至整个排序完成；</li><li>如何避免归并长度相差很大run呢， 依次将run压入栈中，若栈顶run X，run Y，run Z 的长度违反了<strong>X&gt;Y+Z 或 Y&gt;Z</strong> 则Y run与较小长度的run合并，并再次放入栈中。 依据这个法则，能够尽量使得大小相同的run合并，以提高性能。注意Timsort是稳定排序故只有相邻的run才能归并。</li><li>Merge操作还可以辅之以galloping模型（记录归并时run的界值，如runA完全小于或大于runB直接合并，提升归并效率</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>timsort是工业级算法，其混用插入排序与归并排序，二分搜索等算法</p><p>充分利用待排序数据可能部分有序的事实，并且依据待排序数据内容动态改变排序策略——选择性进行归并以及galloping</p><p>Timsort是稳定的算法，当待排序的数组中已经有排序好的数，它的时间复杂度会小于n logn。Timesrot稳定（最坏和平均时间一致），时间复杂度是O（n log n）。在最坏情况下，Timsort算法需要的临时空间是n/2，在最好情况下，它只需要一个很小的临时存储空间</p><h2 id="TimSort–python实现"><a href="#TimSort–python实现" class="headerlink" title="TimSort–python实现"></a>TimSort–python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">二分搜索用于插入排序寻找插入位置</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(the_array, item, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start == end:</span><br><span class="line">        <span class="keyword">if</span> the_array[start] &gt; item:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> start + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> start &gt; end:</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line">    mid = round((start + end)/ <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> the_array[mid] &lt; item:</span><br><span class="line">        <span class="keyword">return</span> binary_search(the_array, item, mid + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> the_array[mid] &gt; item:</span><br><span class="line">        <span class="keyword">return</span> binary_search(the_array, item, start, mid - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">插入排序用于生成mini run</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(the_array)</span>:</span></span><br><span class="line">   </span><br><span class="line">    l = len(the_array)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, l):</span><br><span class="line">        value = the_array[index]</span><br><span class="line">        pos = binary_search(the_array, value, <span class="number">0</span>, index - <span class="number">1</span>)</span><br><span class="line">        the_array[pos+<span class="number">1</span>:index+<span class="number">1</span>] = the_array[pos:index]</span><br><span class="line">        the_array[pos] = value</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> the_array</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">归并，将两个有序的list合并成新的有序list</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> right:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    l_len = len(left)</span><br><span class="line">    r_len = len(right)</span><br><span class="line">    result = [<span class="keyword">None</span>]*(l_len+r_len)</span><br><span class="line">    i, j, k= <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; l_len <span class="keyword">and</span> j&lt; r_len:</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result[k] = left[i]</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result[k] = right[j]</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;l_len:</span><br><span class="line">        result[k]=left[i];</span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;r_len:</span><br><span class="line">        result[k]=right[j]</span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line">        j+=<span class="number">1</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timsort</span><span class="params">(the_array)</span>:</span></span><br><span class="line">    runs = []</span><br><span class="line">    length = len(the_array)</span><br><span class="line">    new_run = [the_array[<span class="number">0</span>]]</span><br><span class="line">    new_run_reverse = <span class="keyword">False</span></span><br><span class="line">    <span class="comment"># 将the_array拆分成多了(递增或严格递减)list并将严格递减的list反转后存入runs。</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> len(new_run) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> the_array[i] &lt; the_array[i<span class="number">-1</span>]:</span><br><span class="line">                new_run_reverse = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_run_reverse = <span class="keyword">False</span></span><br><span class="line">            new_run.append(the_array[i])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">elif</span> new_run_reverse:</span><br><span class="line">            <span class="keyword">if</span> the_array[i] &lt; the_array[i<span class="number">-1</span>]:</span><br><span class="line">                new_run.append(the_array[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_run.reverse()</span><br><span class="line">                runs.append(new_run)</span><br><span class="line">                <span class="comment">#print(new_run)</span></span><br><span class="line">                new_run=[]</span><br><span class="line">                new_run.append(the_array[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> the_array[i] &gt;= the_array[i<span class="number">-1</span>]:</span><br><span class="line">                new_run.append(the_array[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                runs.append(new_run)</span><br><span class="line">                <span class="comment">#print(new_run)</span></span><br><span class="line">                new_run=[]</span><br><span class="line">                new_run.append(the_array[i])</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> i == length - <span class="number">1</span>:</span><br><span class="line">            runs.append(new_run)</span><br><span class="line">            <span class="comment">#print(new_run)</span></span><br><span class="line"></span><br><span class="line">    mini_run = <span class="number">32</span></span><br><span class="line">    sorted_runs=[]</span><br><span class="line">    cur_run=[]</span><br><span class="line">    <span class="comment"># 对runs中的每一项list长度不足mini_run用插入排序进行扩充，存入sorted_runs</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> runs:</span><br><span class="line">        <span class="keyword">if</span> len(cur_run) &gt; mini_run:</span><br><span class="line">            sorted_runs.append(insertion_sort(cur_run))</span><br><span class="line">            cur_run = item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur_run.extend(item)</span><br><span class="line">      </span><br><span class="line">    sorted_runs.append(insertion_sort(cur_run))</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 依次将run压入栈中，若栈顶run X，Y，Z。</span></span><br><span class="line">    <span class="comment"># 违反了X&gt;Y+Z 或 Y&gt;Z 则Y与较小长度的run合并，并再次放入栈中。</span></span><br><span class="line">    <span class="comment"># 依据这个法则，能够尽量使得大小相同的run合并，以提高性能。</span></span><br><span class="line">    <span class="comment"># Timsort是稳定排序故只有相邻的run才能归并。</span></span><br><span class="line">    run_stack = []</span><br><span class="line">    sorted_array = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> run <span class="keyword">in</span> sorted_runs:</span><br><span class="line">        run_stack.append(run)</span><br><span class="line">        stop = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> len(run_stack) &gt;= <span class="number">3</span> <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">            </span><br><span class="line">            X = run_stack[len(run_stack)<span class="number">-1</span>]</span><br><span class="line">            Y = run_stack[len(run_stack)<span class="number">-2</span>]</span><br><span class="line">            Z = run_stack[len(run_stack)<span class="number">-3</span>]</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> len(X)&gt;len(Y)+len(Z)) <span class="keyword">or</span> (<span class="keyword">not</span> len(Y)&gt;len(Z)):</span><br><span class="line">                run_stack.pop()</span><br><span class="line">                run_stack.pop()</span><br><span class="line">                run_stack.pop()</span><br><span class="line">                <span class="keyword">if</span> len(X) &lt; len(Z):</span><br><span class="line">                    YX = merge(Y,X)</span><br><span class="line">                    run_stack.append(Z)</span><br><span class="line">                    run_stack.append(YX)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ZY = merge(Z,Y)</span><br><span class="line">                    run_stack.append(ZY)</span><br><span class="line">                    run_stack.append(X)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stop =<span class="keyword">True</span></span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">#将栈中剩余的run归并</span></span><br><span class="line">    <span class="keyword">for</span> run <span class="keyword">in</span> run_stack:</span><br><span class="line">        sorted_array = merge(sorted_array, run)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="comment">#print(sorted_array)</span></span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">    data.append(random.randint(<span class="number">0</span>,<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line">start = time.process_time()</span><br><span class="line">timsort(data)</span><br><span class="line">end = time.process_time()</span><br><span class="line">print(end-start)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sort-和sorted&quot;&gt;&lt;a href=&quot;#sort-和sorted&quot; class=&quot;headerlink&quot; title=&quot;sort()和sorted()&quot;&gt;&lt;/a&gt;sort()和sorted()&lt;/h2&gt;&lt;p&gt;区别介绍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;sor
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/08/15/LeetCode93/"/>
    <id>http://blog.imlch.cn/2020/08/15/LeetCode93/</id>
    <published>2020-08-15T10:37:35.600Z</published>
    <updated>2020-11-06T12:03:00.708Z</updated>
    
    <content type="html"><![CDATA[<p> ##思路</p><ul><li><p>res List[str]：记录当前已被分隔的字符串，初始值为 [s]，未做分隔</p></li><li><p>for 循环 3 次，每次给 res 中所有字符串加一个 ‘.’，多分隔出一个整数，例如 [“2552551135”] 一次循环之后，变成 [“2.552551135”, “25.52551135”, “255.2551135”]，分隔出了一个合法整数</p></li><li><p>然后在最后面的那串又加 ‘.’，继续分隔，维护好加 ‘.’ 分隔的位置</p></li><li>添加三个 ‘.’ 后，分隔出的前三个整数都已满足条件，只需检验一下分隔出的最后一个整数即可，若满足条件，则四个整数都满足条件</li></ul><p>##代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">and</span> int(s) &lt; <span class="number">256</span>:</span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>] != <span class="string">'0'</span> <span class="keyword">or</span> s == <span class="string">'0'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span>:</span></span><br><span class="line">    res = [s]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        res_now = []</span><br><span class="line">        <span class="keyword">for</span> si <span class="keyword">in</span> res:</span><br><span class="line">            last = si.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line">            idx = len(si) - len(last)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(last)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> int(last[:i + <span class="number">1</span>]) &lt; <span class="number">256</span>:</span><br><span class="line">                    si_now = si[: idx + i + <span class="number">1</span>] + <span class="string">'.'</span> + si[idx + i + <span class="number">1</span> :]</span><br><span class="line">                    res_now.append(si_now)</span><br><span class="line">                <span class="keyword">if</span> last[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        res = res_now</span><br><span class="line"></span><br><span class="line">    res_now = []</span><br><span class="line">    <span class="keyword">for</span> si <span class="keyword">in</span> res:</span><br><span class="line">        last = si.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> self.validInt(last):</span><br><span class="line">            res_now.append(si)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res_now</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; ##思路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;res List[str]：记录当前已被分隔的字符串，初始值为 [s]，未做分隔&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;for 循环 3 次，每次给 res 中所有字符串加一个 ‘.’，多分隔出一个整数，例如 [“2552551135
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/08/15/LeetCode99/"/>
    <id>http://blog.imlch.cn/2020/08/15/LeetCode99/</id>
    <published>2020-08-15T10:18:26.883Z</published>
    <updated>2020-09-19T11:44:46.028Z</updated>
    
    <content type="html"><![CDATA[<p>##方法一：显式中序遍历</p><p>###思路与算法</p><p>对于二叉搜索树进行中序遍历，得到的值序列是递增有序的；对于两个错误的节点等价于在这个值序列中交换了两个值，破坏了值序列的递增性。那么序列中就会出现两个位置不满足或者一个位置不满足递增的两种情况</p><p>###解决方案</p><ul><li>中序递归遍历整个树，当 pre 节点值大于当前节点，记录这两个节点。</li><li>判断逆序对节点数是2个还是4个，如果是2两个，交换即可，如果是4个，则交换第1个和第4个。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_inorder</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 遍历左子树</span></span><br><span class="line">            _inorder(root.left)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">nonlocal</span> pre, nodes</span><br><span class="line">            <span class="keyword">if</span> pre <span class="keyword">and</span> pre.val &gt; root.val:  <span class="comment"># 记录当前的逆序对</span></span><br><span class="line">                nodes.append(pre)</span><br><span class="line">                nodes.append(root)</span><br><span class="line">            pre = root</span><br><span class="line">            <span class="comment"># 遍历右子树</span></span><br><span class="line">            _inorder(root.right)</span><br><span class="line"></span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        nodes = []</span><br><span class="line">        _inorder(root)</span><br><span class="line">        <span class="keyword">if</span> len(nodes) == <span class="number">2</span>:</span><br><span class="line">            i, j = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> len(nodes) == <span class="number">4</span>:</span><br><span class="line">            i, j = <span class="number">0</span>, <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        nodes[i].val, nodes[j].val = nodes[j].val, nodes[i].val</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##方法一：显式中序遍历&lt;/p&gt;
&lt;p&gt;###思路与算法&lt;/p&gt;
&lt;p&gt;对于二叉搜索树进行中序遍历，得到的值序列是递增有序的；对于两个错误的节点等价于在这个值序列中交换了两个值，破坏了值序列的递增性。那么序列中就会出现两个位置不满足或者一个位置不满足递增的两种情况&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.imlch.cn/2020/08/15/LeetCode100/"/>
    <id>http://blog.imlch.cn/2020/08/15/LeetCode100/</id>
    <published>2020-08-15T09:39:26.995Z</published>
    <updated>2020-08-15T09:57:38.461Z</updated>
    
    <content type="html"><![CDATA[<p>##整体思路</p><ul><li>两个树相同，中根遍历肯定相同；中根遍历相同，两个树就一定相同？不一定，比如这种情况，中根遍历都是 [1,2]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br></pre></td></tr></table></figure><ul><li><p>如果中根遍历，先根遍历，后根遍历均相同，那肯定是相同的树。但遍历 3 遍，时间复杂度太高。这道题是简单，显然不会这么复杂</p></li><li><p>中根遍历只记录非空「值」，如果将没有空节点也记录，可以通过判断遍历结果（[1,2,null], [1,null,2]）是否相同来判断两个树是否相同。解法一：通过遍历结果是否相同来判断。</p></li><li><p>解法二：通过两个数组是否完全相同来判断，其实也是依次判断每一个元素是否相同，如果都相同，则最终结果相同。依次判断每一个节点是否相同，相同为 true，不同为 false，存在 false，则最后结果为 false。</p></li></ul><p>###解法一：通过判断遍历结果是否相同<br>时间复杂度：O(N)，递归栈的深度为节点的数量（N）<br>空间复杂度：O(N)，需要一个额外长度为 N 的数组（不考虑叶子节点为 null 的情况）</p><p>###代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        arrp,arrq = [],[]</span><br><span class="line">        self.traversal(p,arrp)</span><br><span class="line">        self.traversal(q,arrq)</span><br><span class="line">        <span class="keyword">return</span> arrp == arrq</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span><span class="params">(self, root: TreeNode, arr: List[int])</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    arr.append(root.val)</span><br><span class="line">    <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">        self.traversal(root.left,arr)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        arr.append(<span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">        self.traversal(root.right,arr)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        arr.append(<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>###解法二：依次判断每一个节点是否相同<br>时间复杂度：O(N)，递归栈的深度为节点的数量（N）<br>空间复杂度：O(1)，不需要额外的空间</p><p>###代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">or</span> q == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##整体思路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个树相同，中根遍历肯定相同；中根遍历相同，两个树就一定相同？不一定，比如这种情况，中根遍历都是 [1,2]&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
  </entry>
  
</feed>
